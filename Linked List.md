# 연결 리스트

조악하게 요약하면, 배열을 고상하게 말하는 거라고 할 수 있겠지만, 절대 아니다. 배열에는 치명적인 문제점이 있다.

## 배열의 문제점: 수정 시의 시간복잡도

배열에 뭔가 새로운 원소를 삽입/삭제하려면 삭제 이후 빈 칸을 메우기 위해 빈칸 뒤의 **모든** 원소가 이동한다.

즉, 최악의 경우 맨 앞 자리에 새로운 원소를 삽입/삭제한다면 나머지 모든 원소들을 이동해야 하는 불상사가 발생한다. 삽입/삭제 한 번 하겠다고 시간복잡도가 $O(n)$인 연산을 돌리는 미친 짓을 해야 하는 셈이다.

## 연결 리스트란?

각 원소(노드)들 자신이 다른 노드와의 연결 관계를 저장하고 있는 형태의 자료 구조다. 단일 연결 리스트와 이중 연결 리스트가 있으며, 후자가 일반적으로 더 많이 쓰인다.

## 단일 연결 리스트

단일 연결 리스트에서, 노드는 그 자신이 저장하고 있는 원소의 값뿐만 아니라, 자신 바로 뒤에 오는 노드의 주소 값까지 저장하고 있다.
즉 모든 노드는 자기 바로 뒤에 오는 노드와 논리적으로 연결된 셈이다. (하지만 앞의 노드와는 연결되지 않는다)

### 단일 연결 리스트에서의 삽입/삭제

연결 리스트의 맨 앞에 원소를 삽입하는 과정은 간단한데, 아무 노드나 한 개 새로 만든 이후, 그 노드가 저장하는 주소 값을 현재 노드의 head 노드의 주소 값으로 잡는다. 그 이후, 새로 삽입한 노드가 head 노드라고 선언하면 된다.

맨 뒤에 원소를 삽입하는 과정도 간단하다. 똑같이 노드를 만들되, 이번에는 현재 tail 노드가 저장하고 있는 주소 값(원래는 null)을 새로 추가한 노드의 주소로 바꾸고, 새로 추가한 노드가 tail 노드라고 선언하면 된다.

삭제의 경우, 맨 앞의 원소를 삭제하는 과정은 간단하다. head 노드를 2번째 노드(즉, 현재 head 노드의 포인터가 가리키고 있는 노드로)라고 선언한 이후, 원래 head 노드였던 노드를 삭제하면 끝이다.

