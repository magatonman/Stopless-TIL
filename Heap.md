# 힙(Heap)
## 힙이란?

Data Structure를 만지다 보면 최댓값이나 최솟값을 연속적으로 빼내고 싶을 때가 분명히 있다. 아니, 자주 존재한다.

힙은 이 문제를 해결하기 위해 만들어진 자료 구조라고 할 수 있다.

## 힙 구조의 설계

힙 구조는 완전이진트리로 구성된다.

### 왜 힙은 완전이진트리인가?

힙에 대한 설명은 많지만 왜 힙이 완전이진트리인가에 대한 명쾌한 설명은 찾기 쉽지 않다.
개인적으로 찾아본 결과, 힙을 완전이진트리로 만드는 이유는 시간복잡도의 감소가 가장 큰 이유였다. 

당연하겠지만, 미친 척하고 힙을 변질 트리로 만든 다음 그걸 보고 힙이라고 주장할 수는 있다.
(변질 트리: 모든 부모 노드의 자식 노드가 1개뿐인 트리.)

하지만 트리는 배열이 아니기에, 마음대로 찢고 붙이는 것이 불가능하다. 무조건 두 노드의 값을 하나씩 바꿔 나갈 수밖에 없다.
당연히, 2부터 8까지의 수가 차례대로 들어가 있는 최대힙에 1을 삽입한다면 더할 나위 없이 쉽다. 2의 자녀 노드를 하나 만들고 그 안에 1을 넣으면 되니까.
하지만 그 '최대힙'에 1 대신 9를 삽입한다면? 힙을 아주 들었다가 놓는 것 말고는 방법이 따로 없다.

즉 완전이진트리가 아니라면, 최악의 경우 시간복잡도가 $O(n)$이 나올 수 있다. 게다가 이걸 방지할 방법도 없다.

하지만 잘 짜인 완전이진트리로 만들어진 힙의 경우, 



힙 구조의 최우선적인 목적은 최댓값이나 최솟값(둘 중 설계할 때 필요한 값)이 루트 노드로 가게 하는 것이다. 이는 힙 구조의 모든 subtree에 대해서도 성립하므로, 최대힙에서는 무조건 자녀 노드의 값이 부모 노드보가 작고, 최소힙은 그 반대이다.

이를 좀 더 명확하게 정의하면 '힙 속성(Heap Property)'이라고 할 수 있다.

힙 $A$에서 임의의 주소 $i$인 칸에 저장된 값을 $A[i]$ 라고 한다면, 모든 주소에 대해서...

* 최대힙의 경우: $A[Parent(i)] \ge A[i]$
* 최소힙의 경우: $A[Parent(i)] \le A[i]$

를 항상 만족시킨다. 즉 어떤 주소를 잡던 간에, 부모 노드와 자녀 노드의 값의 대소 관계는 항상 일정하게 나오게 된다.  

이 구조를 만족시키게 트리를 짠다면 루트 노드의 값이 최댓값 / 최솟값이 될 수 있다.

힙 구조는 완전이진트리 형태이다. 즉, 마지막 level만 빼고 모든 level을 채우는 형식의 이진 트리인데, 
힙 구조에서의 자료 구조는 이하와 같이 이루어진다.
* i번째 노드의 부모 노드의 주소: $\lfloor i/2 \rfloor$
* i번째 노드의 자녀 노드의 주소: 좌측은 $2i$, 우측은 $2i+1$.

즉, 부모 노드의 주소를 안다면 자녀 노드 2종의 주소를 자연스럽게 알 수 있고, 그 반대 역시 마찬가지이다.

## 힙에 원소를 삽입하는 방법

힙(으로 추정되는 무엇인가)을 보았을 때, 특정 노드에서 부모-자녀 노드 간에 최대힙 / 최소힙의 대소 관계를 만족하지 않는 부분이 있다면 그 배열-내지는 Tree 구조는 더 이상 힙이라고 부를 수 없다.
이를 해결하기 위해, 그 문제의 부분을 '힙화(Heapify)' 하는 과정이 필요하다.

* 최대힙의 경우
$$ l=Left(i) $$
$$ r=Right(i) $$
$$ if  l \ge A의 크기 and A[l]>A[i]: max=l $$
$$ else max=i $$
$$ if r \ge A의 크기 and A[r]>A[max]: max=r $$
$$ if max \ne i: A[i]의 값과 A[max]의 값을 맞바꾸고 max 주소의 노드에서 이 알고리즘을 다시 한 번 반복 $$
