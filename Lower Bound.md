# 문제의 시간복잡도의 상한선?

특정한 문제 $\Pi$가 있을 때, 이 문제의 최악의 경우의 시간복잡도는 그 문제($\Pi$)를 해결할 수 있는 가장 빠른 알고리즘의 최악의 경우의 실행 시간과 동일하다.

이 경우 문제 $\Pi$의 복잡도의 상한선은 알고리즘 A가 가르게 된다.

# 문제의 시간복잡도

Q: 그렇다면 어떤 문제가 해결에 오래 걸린다(ex) $O(n^3)$)는 것은 어떻게 증명하는가?

A: $T_{\Pi}(n)=\Omega(f(n))$
임을 증명하기 위해서는 그 문제
$\Pi$ 를 풀 수 있는 어떤 알고리즘도 최악의 실행 시간이 $\Omega(f(n))$임을 증명하면 된다.

Q: 모든 알고리즘을 다 실험하는 것은 미친 짓이 아닌가?

A: 미친 짓 맞다. 적절하게 몇 개만 찾아봐야 한다.

# 예시: 결정 Tree와 이진 탐색

조악하게 말하자면, 결정 Tree는 연상 퀴즈나 스무고개를 고상하게 말하는 것에 불과하다.
특정한 질문이 주어지고(주의: 객관식임), 
그 질문의 결과에 따라서 좀 더 추상적인 질문에서 구체적인 질문으로 질문이 바뀌면서 정답의 범위를 좁혀 나간다.

결정 Tree의 시간 복잡도는 어떻게 될까?

이를 **극단적으로** 적용한 것이 이진 탐색라고 할 수 있다. 모든 질문은 단 한 종류의 질문,
'**Pivot보다 큰가?**''로 귀결되며, 참이면 Pivot과 Pivot의 우측, 거짓이면 Pivot의 좌측으로 만들어지는 부분 배열 안에서 똑같은 질문의 반복으로 이루어진다.

답이 N가지로 나올 수 있는 결정 Tree에서 질문의 종류가 k가지라고 할 때, 이 결정 Tree의 깊이는
$\lceil\log_k N\rceil=\Omega(log N)$
이 된다.

이진 탐색의 경우, $\lceil\lg N\rceil$이기 때문에 이진 탐색 트리의 깊이 역시 $Omega(logN)$이다.

이진 탐색 트리가 완전균형 BST라면 상한값이 $O(logN)$이므로 이 문제에서 시간복잡도가 로그로 나온다는 사실을 증명한다.

* 해싱을 쓰면 O(1)이 나오는데, 이건 k=N인 케이스. 시간복잡도의 일반화에는 도움이 안 되므로 적합한 예시라 할 수 없다.

